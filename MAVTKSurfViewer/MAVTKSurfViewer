#!/usr/bin/python3
###
#ident "University of Edinburgh $Id$"
# \file         MAVTKSurfViewer.py
# \author       Bill Hill
# \date         December 2015
# \version      $Id$
# \par
# Address:
#               MRC Human Genetics Unit,
#               MRC Institute of Genetics and Molecular Medicine,
#               University of Edinburgh,
#               Western General Hospital,
#               Edinburgh, EH4 2XU, UK.
# \par
# Copyright (C), [2015],
# The University Court of the University of Edinburgh,
# Old College, Edinburgh, UK.
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be
# useful but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
# PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public
# License along with this program; if not, write to the Free
# Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
# Boston, MA  02110-1301, USA.
# \brief        Interactive display of surfaces with export to various
#               systems..
# \ingroup      MAVTKApps
###

from __future__ import print_function

import io
import os
import re
import sys
import json
import math
import time
import argparse
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import QT_VERSION_STR, PYQT_VERSION_STR
import vtk
from vtk.qt.QVTKRenderWindowInteractor import QVTKRenderWindowInteractor


_debug = False

html_page = [ \
#0
r"""
<!DOCTYPE html>
<html lang="en">
<head>
""",
#<title>Export from MAVTKSurfViewer</title>
#1
r"""
<meta charset="utf-8">
<style>
body {
  font-family      : Monospace;
  background-color : #000;
  color            : #fff;
  margin           : 0px;
  overflow         : hidden;
}
</style>
</head>

<body>
""",
#2
#<div id="info">
#Export from MAVTKSurfViewer
#</div>
r"""
<script src="js/three.min.js"></script>
<script src="js/TrackballControls.js"></script>
<script src="js/STLLoader.js"></script>
<script src="js/MAVTKLoader.js"></script>
<script src="js/Detector.js"></script>
<script src="js/MARender.min.js"></script>

<script>
pickHandler = function(e) {
  var txt = 'Objects (front to back):\n';
  for(var i = 0; i < e.hitlist.length; ++i) {
    var hit = e.hitlist[i].object;
    txt = txt + '  ' + hit.name + '\n';
  }
  window.alert(txt);
}

if(!(Detector.webgl)) {
  Detector.addGetWebGLMessage();
}

var container;
container = document.createElement('div');
document.body.appendChild(container);

var ren = new MARenderer(window, container);
ren.init();
""",
#3
r"""
ren.addEventListener('pick', pickHandler);
ren.animate();
</script>
</body>
</html>"""
]

###
# \function   debugMsg
# \brief      Prints a debug message (to stderr) if debugging is enabled.
###
def debugMsg(msg): #{
  global _debug
  if _debug: #{
    print(msg, file=sys.stderr)
  #}
#}

###
# \function   warnMsg
# \brief      Prints a warning message.
###
def warnMsg(msg): #{
  print(msg, file=sys.stderr)
#}

##class       MAVTKCameraSettings
# \brief       Data structure which holds sufficient camera data to
#              save/restore a view.
###
class MAVTKCameraSettings(): #{
  position = [0.0, 0.0, 0.0]
  focalPoint = [0.0, 0.0, 0.0]
  viewUp = [0.0, 0.0, 0.0]
  viewAngle = 0.0
  parallelScale = 1.0
  clippingRange = [ 1.0, 1000.0]
#}

###
# \class       MAVTKRenderer
# \brief       Provides a single QFrame for rendering using VTK with
#              interaction (default camera trackball) and picker.
###
class MAVTKRenderer(): #{

  def __init__(self): #{
    self.initUI()
  #}
    
  ###
  # \function   initUI
  # \brief      Create VTK QFrame for rendering.
  ###
  def initUI(self): #{
    self._frame = QtWidgets.QFrame()
    vl = QtWidgets.QVBoxLayout()
    self.vtkWidget = QVTKRenderWindowInteractor(self._frame)
    vl.addWidget(self.vtkWidget)
    self._frame.setLayout(vl)
  #}

  ###
  # \function   init
  # \brief      Create the VTK rendering system.
  ###
  def init(self): #{
    self._ren = vtk.vtkRenderer()
    self._picker = vtk.vtkCellPicker()
    self._renWin = self.vtkWidget.GetRenderWindow()
    debugMsg(self._renWin)
    self._renWin.AddRenderer(self._ren)
    iren  = self._renWin.GetInteractor()
    istyle = vtk.vtkInteractorStyleSwitch()
    iren.SetInteractorStyle(istyle)
    istyle.SetCurrentStyleToTrackballCamera()
    iren.SetPicker(self._picker)
    iren.Initialize()
  #}

  ###
  # \function  getIRen
  # \brief     Access the VTK render window interactor.
  ###
  def getIRen(self): #{
    return self._renWin.GetInteractor()
  #}

  ###
  # \function  getRenWin
  # \brief     Access the VTK render window.
  ###
  def getRenWin(self): #{
    return self._renWin
  #}

  ###
  # \function  getView
  # \brief     Get current camera view.
  ###
  def getView(self): #{
    cam = self._ren.GetActiveCamera()
    v = MAVTKCameraSettings()
    v.position = cam.GetPosition()
    v.focalPoint = cam.GetFocalPoint()
    v.viewUp = cam.GetViewUp()
    v.viewAngle = cam.GetViewAngle()
    v.parallelScale = cam.GetParallelScale()
    v.clippingRange = cam.GetClippingRange()
    return v
  #}

  ###
  # \function  setView
  # \brief     Set camera view.
  # \param v                 Given camera view.
  ###
  def setView(self, v): #{
    cam = self._ren.GetActiveCamera()
    cam.SetPosition(v.position)
    cam.SetFocalPoint(v.focalPoint)
    cam.SetViewUp(v.viewUp)
    cam.SetViewAngle(v.viewAngle)
    cam.SetParallelScale(v.parallelScale)
    cam.SetClippingRange(v.clippingRange)
    self.Render()
  #}


  ###
  # \function   getRen
  # \brief      Access the renderer.
  ###
  def getRen(self): #{
    return self._ren
  #}

  ###
  # \function   getPicker
  # \brief      Access the object picker.
  ###
  def getPicker(self): #{
    return self._picker
  #}

  ###
  # \function   getFilename
  # \brief      Access the renderer's frame widget.
  ###
  def getFrame(self): #{
    return self._frame
  #}

  ###
  # \function  Render
  # \brief     Forces a render update even if the render window doesn't have
  #            focus.
  ###
  def Render(self): #{
   self._renWin.Render()
   self.vtkWidget.update()
 #}

  ###
  # \function  writeFrameToFile
  # \brief     Force a re-rendering and then capture the frame image and
  #            write it to a file with the given path.
  # \param path                File path in which the extension is used to
  #                            determine the image format used.
  ###
  def writeFrameToFile(self, path): #{
    ok = True
    file_type = path.split(".")[-1]
    img = vtk.vtkWindowToImageFilter()
    writer = None
    if file_type == 'bmp': #{
      writer = vtk.vtkBMPWriter()
    elif file_type == 'png': #}{
      writer = vtk.vtkPNGWriter()
    elif file_type == 'pnm' or file_type == 'ppm': #}{
      writer = vtk.vtkPNMWriter()
    elif file_type == 'tif' or file_type == 'tiff': #}{
      writer = vtk.vtkTIFFWriter()
    #}
    if(writer): #{
      img.SetInput(self._renWin)
      writer.SetInputConnection(img.GetOutputPort())
      writer.SetFileName(str(path))
      self._ren.Render()
      writer.Write()
    else: #}{
      ok = False
      result = QtWidgets.QMessageBox.critical(self._frame,
                   'Error',
                   'Unsupported file format (' + str(file_type) + ').',
                   QtWidgets.QMessageBox.Close)
    #}
    return not ok
  #}
#}

###
# \class       MAVTKActorTable
# \brief       Inherits from QDialog and contains a QTableWidget which is
#              used to display and interact with actor properties.
###
class MAVTKActorTable(QtWidgets.QDialog): #{

  colorChangeSignal = QtCore.pyqtSignal(int, QtGui.QColor)
  opacityChangeSignal = QtCore.pyqtSignal(int, float)
  visableChangeSignal = QtCore.pyqtSignal(int, bool)

  def __init__(self): #{
    super(MAVTKActorTable, self).__init__()
    self._tableDict = {'Index'   : 0,
                       'Visible' : 1,
                       'Name'    : 2,
                       'Color'   : 3,
                       'Opacity' : 4,
                       'Path'    : 5}
    self._tableKeys = ['Index', 'Visible', 'Name', 'Color', 'Opacity', 'Path']
    self._actors = []
    self.initUI()
  #}

  def initUI(self): #{
    self.setWindowTitle('Actor Table')
    self. setMinimumWidth(600)
    vl = QtWidgets.QVBoxLayout()
    self.setLayout(vl)
    self._table = QtWidgets.QTableWidget(0, 6)
    vl.addWidget(self._table)
    but = QtWidgets.QDialogButtonBox(
              QtWidgets.QDialogButtonBox.Cancel,
              QtCore.Qt.Horizontal, self)
    but.rejected.connect(self.cancel)
    vl.addWidget(but)
    self._table.setSizePolicy(QtWidgets.QSizePolicy.Expanding,
                             QtWidgets.QSizePolicy.Expanding)
    self._table.verticalHeader().setVisible(False)
    self._table.horizontalHeader().setStretchLastSection(True)
    self._table.setHorizontalHeaderLabels(self._tableKeys)
    self._table.cellClicked.connect(self.cellClicked)
    self._table.cellChanged.connect(self.cellChanged)
    self._table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
  #}

  ###
  # \function   cancel
  # \brief      Slot to hide the dialog.
  ###
  def cancel(self): #{
    self.hide()
  #}

  ###
  # \function   textToFloat
  # \brief      Converts the given string to a float.
  # \return     Float value (0.0 if not a float).
  ###
  def textToFloat(self, txt): #{
    try: #{
      val = float(txt)
      if(val < 0.0):
        val = 0.0
      elif(val > 1.0):
        val = 1.0
    except ValueError: #}{
      val = 0.0
    #}
    return val
  #}

  ###
  # \function  delActor
  # \brief     Not implemented. There is currently no actor deletion,
  #            this allows simple index based actor selection
  ###
  def delActor(self, idx): #{
    warnMsg('delActor() - not implemented')
  #}

  ###
  # \function   addActor
  # \brief      Adds an actor.
  ###
  def addActor(self, actor, visible, name, color, opacity, path): #{
    idx = len(self._actors)
    self._actors.insert(idx, actor)
    self._table.insertRow(idx)
    self._setActorIndex(idx)
    self._setActorName(idx, name)
    self.setActorColor(idx, color)
    self.setActorOpacity(idx, opacity)
    self.setActorPath(idx, path)
    self.setActorVisible(idx, visible)
  #}

  ###
  # \function  _setActorIndex
  # \brief     Sets the index in the table.
  # \param idx                 Given index.
  ###
  def _setActorIndex(self, idx): #{
    itm = QtWidgets.QTableWidgetItem(str(idx))
    itm.setFlags(itm.flags() & (~QtCore.Qt.ItemIsEditable))
    self._table.setItem(idx, self._tableDict['Index'], itm)
  #}

  ###
  # \function  setActorVisible
  # \brief     Sets actor visability in the table.
  # \param idx                 Given index.
  # \param state               actor visability (boolean).
  ###
  def setActorVisible(self, idx, state): #{
    itm = QtWidgets.QTableWidgetItem(str(state))
    itm.setFlags(itm.flags() & (~QtCore.Qt.ItemIsEditable))
    self._table.setItem(idx, self._tableDict['Visible'], itm)
  #}

  ###
  # \function  _setActorName
  # \brief     Sets the actor name for the given index in the table.
  # \param idx                 Given index.
  # \param name                Given actor name to set.
  ###
  def _setActorName(self, idx, name): #{
    itm = QtWidgets.QTableWidgetItem(name)
    self._table.setItem(idx, self._tableDict['Name'], itm)
  #}

  ###
  # \function  setActorColor
  # \brief     Sets the actor colour for the given index in the table.
  # \param idx                 Given index.
  # \param name                Given actor colour as a QColor.
  ###
  def setActorColor(self, idx, color): #{
    itm = QtWidgets.QTableWidgetItem()
    itm.setData(QtCore.Qt.BackgroundRole, color)
    itm.setFlags(itm.flags() & (~QtCore.Qt.ItemIsEditable))
    self._table.setItem(idx, self._tableDict['Color'], itm)
  #}

  ##
  # \function  
  # \brief     Sets the actor opacity for the given index in the table.
  # \param idx                 Given index.
  # \param opacity             Given actor opacity.
  ###
  def setActorOpacity(self, idx, opacity): #{
    setval = not bool(self._table.item(idx, self._tableDict['Opacity']))
    if(not setval): #{
      txt = self._table.item(idx, self._tableDict['Opacity']).text()
      val = self.textToFloat(txt)
      if(math.fabs(val - opacity) >= 0.0001): #{
        opacity = val
        setval = true
      #}
    #}
    if(setval): #{
      itm = QtWidgets.QTableWidgetItem(str(opacity))
      self._table.setCellWidget(idx, self._tableDict['Opacity'], None)
      self._table.setItem(idx, self._tableDict['Opacity'], itm)
    #}
  #}

  ##
  # \function  
  # \brief     Sets the actor file path for the given index in the table.
  # \param idx                 Given index.
  # \param path                Given actor file path.
  ###
  def setActorPath(self, idx, path): #{
    itm = QtWidgets.QTableWidgetItem(path)
    itm.setFlags(itm.flags() & (~QtCore.Qt.ItemIsEditable))
    self._table.setItem(idx, self._tableDict['Path'], itm)
  #}

  ###
  # \function   selectActor
  # \brief      Select actor in table given it's index.
  ###
  def selectActor(self, idx): #{
    self._table.selectRow(idx)
  #}

  ###
  # \function   getNumActors
  # \brief      Access the number of actors in the table.
  # \return     Number of actors in the table.
  ###
  def getNumActors(self): #{
    return self._table.rowCount()
  #}

  ###
  # \function   getActor
  # \brief      Access an actor in the table given it's index.
  # \return     The actor.
  ###
  def getActor(self, idx): #{
    actor = self._actors[idx]
    return actor
  #}

  ###
  # \function   getActorVisability
  # \brief      Access the actor's visibility.
  # \return     Whether the actor is visible (boolean).
  ###
  def getActorVisability(self, idx): #{
    vis = 'True' == \
          str(self._table.item(idx, self._tableDict['Visible']).text())
    return vis
  #}

  ###
  # \function   getActorName
  # \brief      Access an actor's name given it's index in the table.
  # \return     Actor name.
  ###
  def getActorName(self, idx): #{
    name = str(self._table.item(idx, self._tableDict['Name']).text())
    return name
  #}

  ###
  # \function   getActorColor
  # \brief      Access actor's colour given it's index.
  # \return     The actors colour (QColor).
  ###
  def getActorColor(self, idx): #{
    q_col = self._table.item(idx, self._tableDict['Color']).data(QtCore.Qt.BackgroundRole)
    return q_col
  #}

  ###
  # \function getActorOpacity
  # \brief    Acces actor's opacity given it's index.
  # \return   Actor's opacity.
  ###
  def getActorOpacity(self, idx): #{
    opacity = float(self._table.item(idx, self._tableDict['Opacity']).text())
    return opacity
  #}

  ###
  # \function getActorPath
  # \brief    Access actor's file path.
  # \return   File path string.
  ###
  def getActorPath(self, idx): #{
    path = str(self._table.item(idx, self._tableDict['Path']).text())
    return path
  #}

  ###
  # \function cellClicked
  # \brief    Slot for cell of table clicked.
  ###
  def cellClicked(self, idx, prop): #{
    if prop == self._tableDict['Visible']: #{
      vis = not self.getActorVisability(idx)     
      self.visableChangeSignal.emit(idx, vis)
    elif prop == self._tableDict['Color']: #}{
      col = QtWidgets.QColorDialog.getColor()
      if col.isValid(): #{
        self.colorChangeSignal.emit(idx, col)
      #}
    #}
  #}

  ###
  # \function cellChanged
  # \brief    Slot for cell in table changed.
  ###
  def cellChanged(self, idx, prop): #{
    if prop == self._tableDict['Opacity']: #{
      txt = self._table.item(idx, prop).text()
      val = self.textToFloat(txt)
      self.opacityChangeSignal.emit(idx, val)
    #}
  #}
#}


###
# \class       AboutDialog
# \brief       A dialog descended from QDialog which shows basic information
#              about the application.
###
class AboutDialog(QtWidgets.QDialog): #{

  def __init__(self, version, parent = None): #{
    super(AboutDialog, self).__init__(parent)
    self.initUI(version)
  #}

  def initUI(self, version): #{
    msg = ('<b>MAVTKSurfViewer</b>' +
           '<p>Version ' + version + '.</p>' +
           '<p>A VTK based multiple surface viewer.</p>' +
           '<p>ma-tech@igmm.ed.ac.uk</p>' +
           '<p></p>' +
           '<p>python=' + sys.version + '</p>' +
           '<p>qt=' + QT_VERSION_STR + ', pyqt=' + PYQT_VERSION_STR +
               ', vtk=' + vtk.vtkVersion().GetVTKVersion() + '</p>')
    lo = QtWidgets.QVBoxLayout(self)
    txt = QtWidgets.QLabel(msg)
    lo.addWidget(txt)
    but = QtWidgets.QDialogButtonBox(
              QtWidgets.QDialogButtonBox.Cancel,
              QtCore.Qt.Horizontal, self)
    but.rejected.connect(self.cancel)
    lo.addWidget(but)
  #}

  ###
  # \function cancel
  # \brief    Slot to hide dialog.
  ###
  def cancel(self): #{
    self.hide()
  #}
#}
    
###
# \class       ControlsDialog
# \brief       A dialog descended from QDialog which shows basic controls
#              of the render window.
###
class ControlsDialog(QtWidgets.QDialog): #{

  def __init__(self, parent = None): #{
    super(ControlsDialog, self).__init__(parent)
    self.initUI()
  #}

  ###
  # \function initUI
  # \brief    Build the interactive controls help dislog.
  ###
  def initUI(self): #{
    msg = '<b>MAVTKSurfViewer Interactive Controls</b>' + \
    '<br>' + \
    '<p>The visualisation can be controlled by a set of keyboard ' + \
    'and mouse actions which are common across most VTK based ' + \
    'applications</p>' + \
    '<br>' + \
    '<p><table>' + \
    '<tr><td>Key a</td><td> - manipulate the actor</td></tr>' + \
    '<tr><td>Key c</td><td> - manipulate the camera</td></tr>' + \
    '<tr><td>Key j</td><td> - joystick manipulation mode</td></tr>' + \
    '<tr><td>Key t</td><td> - trackball manipulation mode</td></tr>' + \
    '<tr><td>Key p</td><td> - pick actor</td></tr>' + \
    '<tr><td>Key s</td><td> - solid surfaces</td></tr>' + \
    '<tr><td>Key w</td><td> - wireframe surfaces</td></tr>' + \
    '<tr><td>Key 3</td><td> - toggle 3D stereo</td></tr>' + \
    '<tr><td>Button 1</td><td> - rotate</td></tr>' + \
    '<tr><td>Button 2</td><td> - pan</td></tr>' + \
    '<tr><td>Button 3</td><td> - zoom</td></tr>' + \
    '<tr><td>Ctrl-Button 1</td><td> - spin</td></tr>' + \
    '<tr><td>Ctrl-Button 2</td><td> - dolly</td></tr>' + \
    '</table></p>' + \
    '<p>Camera mode, trackball mode and solid surfaces are the defaults ' + \
    'used.</p>'
    lo = QtWidgets.QVBoxLayout(self)
    txt = QtWidgets.QLabel(msg)
    lo.addWidget(txt)
    but = QtWidgets.QDialogButtonBox(
              QtWidgets.QDialogButtonBox.Cancel,
              QtCore.Qt.Horizontal, self)
    but.rejected.connect(self.cancel)
    lo.addWidget(but)
  #}

  ###
  # \function cancel
  # \brief    Slot to hide dialog.
  ###
  def cancel(self): #{
    self.hide()
  #}
#}
    

###
# \class       MovieCreationState
# \brief       Class used for an enum with movie creation states.
###
class MovieCreationState(object): #{
  stop  = 0
  run   = 1
#}

###
# \class       MovieCreationDialog
# \brief       Class for the movie creation dialog.
###
class MovieCreationDialog(QtWidgets.QDialog): #{
  _current_path = ''

  def __init__(self, parent = None): #{
    super(MovieCreationDialog, self).__init__(parent)
    self.initUI()
    self._state = MovieCreationState.stop
  #}

  ###
  # \function   initUI
  # \brief      Creates the movie creation dialog.
  ###
  def initUI(self): #{
    lom = QtWidgets.QVBoxLayout(self)
    self.setWindowTitle('Movie Creation Parameters')
    fr_main = QtWidgets.QFrame()
    buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Cancel,
                  QtCore.Qt.Horizontal, self)
    lom.addWidget(fr_main)
    lom.addWidget(buttons)
    loh  = QtWidgets.QHBoxLayout()
    fr_main.setLayout(loh)
    fr_ttl  = QtWidgets.QFrame()
    fr_fxr  = QtWidgets.QFrame()
    fr_ctl  = QtWidgets.QFrame()
    loh.addWidget(fr_fxr)
    loh.addWidget(fr_ctl)
    lo_fxr  = QtWidgets.QGridLayout(fr_fxr)
    lo_ctl  = QtWidgets.QGridLayout(fr_ctl)
    lb_fxr = QtWidgets.QLabel('Fixed Rotations')
    lb_fxr.setAlignment(QtCore.Qt.AlignCenter)
    lo_fxr.addWidget(lb_fxr, 0, 0, 1, 4)
    lb_nos = QtWidgets.QLabel('Number of Steps')
    lb_nos.setAlignment(QtCore.Qt.AlignLeft)
    lo_fxr.addWidget(lb_nos, 1, 0, 1, 2)
    self._sb_nos = QtWidgets.QSpinBox()
    self._sb_nos.setRange(0, 99999999)
    self._sb_nos.setValue(0)
    lo_fxr.addWidget(self._sb_nos, 1, 3, 1, 1)
    lb_dps = QtWidgets.QLabel('Degrees per Step')
    lb_dps.setAlignment(QtCore.Qt.AlignLeft)
    lo_fxr.addWidget(lb_dps, 2, 0, 1, 2)
    self._sb_dps = QtWidgets.QSpinBox()
    self._sb_dps.setRange(-359, 359)
    self._sb_dps.setValue(0)
    lo_fxr.addWidget(self._sb_dps, 2, 3, 1, 1)
    lb_axis = QtWidgets.QLabel('Axis')
    lb_axis.setAlignment(QtCore.Qt.AlignLeft)
    lo_fxr.addWidget(lb_axis, 3, 0, 1, 2)
    self._cb_axis = QtWidgets.QComboBox()
    self._cb_axis.addItems(['X', 'Y', 'Z'])
    lo_fxr.addWidget(self._cb_axis, 3, 2, 1, 2)
    lb_file = QtWidgets.QLabel('Base file name')
    lb_file.setAlignment(QtCore.Qt.AlignLeft)
    lo_ctl.addWidget(lb_file, 1, 0, 1, 2)
    bt_file = QtWidgets.QPushButton('Browse ...')
    lo_ctl.addWidget(bt_file, 1, 3, 1, 1)
    self._le_path = QtWidgets.QLineEdit('no file')
    lo_ctl.addWidget(self._le_path, 2, 0, 1, 4)
    lb_fix = QtWidgets.QLabel('File index')
    lb_fix.setAlignment(QtCore.Qt.AlignLeft)
    lo_ctl.addWidget(lb_fix, 3, 0, 1, 2)
    self._sb_fix = QtWidgets.QSpinBox()
    self._sb_fix.setRange(0, 99999999)
    self._sb_fix.setValue(0)
    lo_ctl.addWidget(self._sb_fix, 3, 2, 1, 2)
    self._bt_start = QtWidgets.QPushButton('Start')
    lo_ctl.addWidget(self._bt_start, 4, 0, 1, 2)
    self._bt_stop = QtWidgets.QPushButton('Stop')
    lo_ctl.addWidget(self._bt_stop, 4, 2, 1, 2)
    bt_file.clicked.connect(self.selectFile)
    buttons.rejected.connect(self.cancel)
  #}

  ###
  # \function cancel
  # \brief    Slot to hide dialog.
  ###
  def cancel(self): #{
    self.hide()
  #}

  ###
  # \function setStateRun
  # \brief    Sets the movie creation state to run.
  ###
  def setStateRun(self): #{
    self._state = MovieCreationState.run
  #}

  ###
  # \function setStateStop
  # \brief    Sets the movie creation state to stop.
  ###
  def setStateStop(self): #{
    self._state = MovieCreationState.stop
  #}

  ###
  # \function  stateIsStop
  # \brief     Checks the value of the movie creation state flag, but before
  #            doing this makes sure that any Qt events have been processed.
  ###
  def stateIsStop(self): #{
    QtWidgets.QApplication.processEvents()
    return self._state == MovieCreationState.stop
  #}

  ###
  # \function   selectFile
  # \brief      Creates a file dialog and uses it to set the base movie path.
  ###
  def selectFile(self): #{
    path = QtWidgets.QFileDialog.getSaveFileName(self, 'Select base movie file',
               self._current_path,
               'Image files (*.bmp *.png *.pnm *.tif *.tiff);;' +
               'All files (*)')
    if(bool(path)): #{
      self._le_path.setText(path[0])
    #}
  #}
  
  ###
  # \function getNumStep
  # \brief    Access the number of steps in movie creation.
  ###
  def getNumStep(self): #{
    return self._sb_nos.value()
  #}

  ###
  # \function getDegPerStep
  # \brief    Access the number of degrees per step in movie creation.
  ###
  def getDegPerStep(self): #{
    return self._sb_dps.value()
  #}

  ###
  # \function getAxis
  # \brief    Access the axis for rotation in movie creation.
  ###
  def getAxis(self): #{
    return str(self._cb_axis.currentText())
  #}

  ###
  # \function getFileIndex
  # \brief    Access the movie creation base movie path.
  ###
  def getFilename(self): #{
    path = str(self._le_path.text())
    if path == 'no file': #{
      path = None
    #}
    return path
  #}

  ###
  # \function getNumStep
  # \brief    Access the number of steps in movie creation.
  ###
  def getFileIndex(self): #{
    return self._sb_fix.value()
  #}

  ###
  # \function incFileIndex
  # \brief    Slot to increase the file index value.
  ###
  def incFileIndex(self): #{
    self._sb_fix.setValue(self._sb_fix.value() + 1)
  #}

  ###
  # \function getStartPB
  # \brief    Slot to start the timer.
  # \return   Always timer started (boolean).
  ###
  def getStartPB(self): #{
    return self._bt_start
  #}

  ###
  # \function getStopPB
  # \brief    Slot to stop the timer.
  # \return   Always timer stopped (boolean).
  ###
  def getStopPB(self): #{
    return self._bt_stop
  #}
#}

###
# \class       ExportMARDialog
# \brief       Class for a dialog which exports the scene to an MARender
#              web page.
###
class ExportMARDialog(QtWidgets.QDialog): #{

  def __init__(self, parent = None): #{
    super(ExportMARDialog, self).__init__(parent)
    self._buttons = None
    self._le_page_title = None
    self._te_page_info = None
    accepted = QtCore.pyqtSignal()
    self.initUI()
  #}

  ###
  # \function   initUI
  # \brief      Creates the MARender scene export dialog.
  ###
  def initUI(self): #{
    lom = QtWidgets.QVBoxLayout(self)
    self.setWindowTitle('MARender Export Parameters')
    fr_main = QtWidgets.QFrame()
    self._buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | \
                        QtWidgets.QDialogButtonBox.Cancel,
                        QtCore.Qt.Horizontal, self)
    lom.addWidget(fr_main)
    lom.addWidget(self._buttons)
    lov  = QtWidgets.QVBoxLayout()
    fr_main.setLayout(lov)
    fr_ptl  = QtWidgets.QFrame()
    fr_inf  = QtWidgets.QFrame()
    lov.addWidget(fr_ptl)
    lov.addWidget(fr_inf)
    lo_ptl = QtWidgets.QGridLayout(fr_ptl)
    lo_inf = QtWidgets.QGridLayout(fr_inf)
    lb_ptl = QtWidgets.QLabel('Page Title')
    lb_ptl.setAlignment(QtCore.Qt.AlignLeft)
    lo_ptl.addWidget(lb_ptl, 0, 0, 1, 1)
    self._le_page_title = QtWidgets.QLineEdit('Export from MAVTKSurfViewer')
    lo_ptl.addWidget(self._le_page_title, 0, 1, 1, 8)
    lb_inf = QtWidgets.QLabel('Page Info')
    lb_inf.setAlignment(QtCore.Qt.AlignLeft)
    lo_inf.addWidget(lb_inf, 0, 0, 1, 1)
    self._te_page_info = QtWidgets.QTextEdit('Exported from MAVTKSurfViewer')
    lo_inf.addWidget(self._te_page_info, 0, 1, 8, 8)
    self._buttons.accepted.connect(self.ok)
    self._buttons.rejected.connect(self.cancel)
  #}

  ###
  # \function ok
  # \brief    Slot to accept then hide the dialog.
  ###
  def ok(self): #{
    self.accepted.emit()
    self.hide()
  #}

  ###
  # \function cancel
  # \brief    Slot to hide dialog.
  ###
  def cancel(self): #{
    self.hide()
  #}

  ###
  # \function getPageTitle
  # \brief    Access the page title.
  ###
  def getPageTitle(self): #{
    page_title = str(self._le_page_title.text())
    return page_title
  #}

  ###
  # \function getPageInfo
  # \brief    Access the page information text.
  ###
  def getPageInfo(self): #{
    page_info = str(self._te_page_info.toPlainText())
    return page_info
  #}

#}

###
# \class       ExportMARVDialog
# \brief       Class for a dialog which exports the scene to an MARenderView
#              web page configuration file.
###
class ExportMARVDialog(QtWidgets.QDialog): #{

  def __init__(self, parent = None): #{
    super(ExportMARVDialog, self).__init__(parent)
    self._buttons = None
    self._le_page_title = None
    self._te_page_info = None
    self._le_iip_srv = None
    self._sb_ref_idx = None
    accepted = QtCore.pyqtSignal()
    self.initUI()
  #}

  ###
  # \function   initUI
  # \brief      Creates the MARenderView scene export dialog.
  ###
  def initUI(self): #{
    lom = QtWidgets.QVBoxLayout(self)
    self.setWindowTitle('MARenderView Config File  Export Parameters')
    fr_main = QtWidgets.QFrame()
    self._buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | \
                        QtWidgets.QDialogButtonBox.Cancel,
                        QtCore.Qt.Horizontal, self)
    lom.addWidget(fr_main)
    lom.addWidget(self._buttons)
    lov  = QtWidgets.QVBoxLayout()
    fr_main.setLayout(lov)
    fr_ptl = QtWidgets.QFrame()
    fr_inf = QtWidgets.QFrame()
    fr_iip_srv = QtWidgets.QFrame()
    fr_ref_idx = QtWidgets.QFrame()
    lov.addWidget(fr_ptl)
    lov.addWidget(fr_inf)
    lov.addWidget(fr_iip_srv)
    lov.addWidget(fr_ref_idx)
    lo_ptl = QtWidgets.QGridLayout(fr_ptl)
    lo_inf = QtWidgets.QGridLayout(fr_inf)
    lo_iip_srv = QtWidgets.QGridLayout(fr_iip_srv)
    lo_ref_idx = QtWidgets.QGridLayout(fr_ref_idx)
    #
    lb_ptl = QtWidgets.QLabel('Page Title')
    lb_ptl.setAlignment(QtCore.Qt.AlignLeft)
    lo_ptl.addWidget(lb_ptl, 0, 0, 1, 1)
    self._le_page_title = QtWidgets.QLineEdit('Export from MAVTKSurfViewer')
    lo_ptl.addWidget(self._le_page_title, 0, 1, 1, 8)
    #
    lb_inf = QtWidgets.QLabel('Page Info')
    lb_inf.setAlignment(QtCore.Qt.AlignLeft)
    lo_inf.addWidget(lb_inf, 0, 0, 1, 1)
    self._te_page_info = QtWidgets.QTextEdit('Exported from MAVTKSurfViewer')
    lo_inf.addWidget(self._te_page_info, 0, 1, 8, 8)
    #
    lb_iip_srv = QtWidgets.QLabel('IIP3D Server')
    lb_iip_srv.setAlignment(QtCore.Qt.AlignLeft)
    lo_iip_srv.addWidget(lb_iip_srv, 0, 0, 1, 1)
    self._le_iip_srv = QtWidgets.QLineEdit( \
        'http://localhost/fcgi-bin/wlziipsrv.fcgi')
    lo_iip_srv.addWidget(self._le_iip_srv, 0, 1, 1, 8)
    #
    lb_ref_idx = QtWidgets.QLabel('Ref Surface Index')
    lb_ref_idx.setAlignment(QtCore.Qt.AlignLeft)
    lo_ref_idx.addWidget(lb_ref_idx, 0, 0, 1, 1)
    self._sb_ref_idx = QtWidgets.QSpinBox()
    self._sb_ref_idx.setRange(0, 99999999)
    self._sb_ref_idx.setValue(0)
    lo_ref_idx.addWidget(self._sb_ref_idx, 0, 1, 1, 8)
    #
    self._buttons.accepted.connect(self.ok)
    self._buttons.rejected.connect(self.cancel)
  #}

  ###
  # \function ok
  # \brief    Slot to accept then hide dialog.
  ###
  def ok(self): #{
    self.accepted.emit()
    self.hide()
  #}

  ###
  # \function cancel
  # \brief    Slot to hide dialog.
  ###
  def cancel(self): #{
    self.hide()
  #}

  ###
  # \function getPageTitle
  # \brief    Access the page title.
  # \return   The page title.
  ###
  def getPageTitle(self): #{
    page_title = str(self._le_page_title.text())
    return page_title
  #}

  ###
  # \function getPageInfo
  # \brief    Access the page information text.
  # \return   The page information text string (plain text).
  ###
  def getPageInfo(self): #{
    page_info = str(self._te_page_info.toPlainText())
    return page_info
  #}

  ###
  # \function getPageInfo
  # \brief    Access the iip server path.
  # \return   The iip server path.
  ###
  def getIIPSrv(self): #{
    iip_srv = str(self._le_iip_srv.text())
    return iip_srv
  #}

  ###
  # \function getPageInfo
  # \brief    Access the reference actor index.
  # \return   The reference actor index.
  ###
  def getRefIdx(self): #{
    ref_idx = self._sb_ref_idx.value()
    return ref_idx
  #}

#}

###
# \class       MAVTKSurfViewer
# \brief       Main window of the application descended from QMainWindow.
#              This has a menu bar, render window and status bar.
###
class MAVTKSurfViewer(QtWidgets.QMainWindow): #{
  _version = '2.0.0'
  _actor_file_ident = 'MAVTKSurfViewer Actor Settings'
  _file_formats = ['obj', 'stl', 'vtk']
  _animation = 0
  _home = None
  _movie = None
  _export_mar = None
  _export_marv = None

  def __init__(self, files): #{
    super(MAVTKSurfViewer, self).__init__()
    self._current_path = ''
    self._def_opacity = 1.0
    self._def_color = [1.0, 1.0, 1.0]
    self.initUI(files)
  #}

  ###
  # \function   toggleDebug
  # \brief      Slot which toggle the debug state.
  ###
  def toggleDebug(self): #{
    global _debug
    _debug = not _debug
    if _debug: #{
      s = 'on'
    else: #}{
      s = 'off'
    #}
    warnMsg('Debugging ' + s)
  #}

  ###
  # \function   initUI
  # \brief      Creates the application main window.
  ###
  def initUI(self, files): #{
    global _debug
    iCol = [1.0, 1.0, 1.0]
    ## Actor table
    self._actors = MAVTKActorTable()
    ### Menubar
    menubar = self.menuBar()
    fMenu = menubar.addMenu('&File')
    eMenu = menubar.addMenu('&Edit')
    aMenu = menubar.addMenu('&Actions')
    vMenu = menubar.addMenu('&View')
    menubar.addSeparator()
    hMenu = menubar.addMenu('&Help')
    ## 
    fOpen = QtWidgets.QAction(QtGui.QIcon('open.png'), 'Open Actor', self)
    fOpen.setShortcut('Ctrl+O')
    fOpen.setStatusTip('Open new surface file')
    fOpen.triggered.connect(self.openFile)
    fMenu.addAction(fOpen)
    # 
    fSaveImage = QtWidgets.QAction(QtGui.QIcon('save.png'), 'Save Image', self)
    fSaveImage.setShortcut('Ctrl+I')
    fSaveImage.setStatusTip('Save rendered image')
    fSaveImage.triggered.connect(self.saveImage)
    fMenu.addAction(fSaveImage)
    # 
    fSaveActors = QtWidgets.QAction(QtGui.QIcon('save.png'), \
                                'Save Actor Settings', self)
    fSaveActors.setStatusTip('Save actor settings')
    fSaveActors.triggered.connect(self.saveActors)
    fMenu.addAction(fSaveActors)
    #
    self._export_mar = ExportMARDialog()
    fExportActorsMAR = QtWidgets.QAction(
                                'Export Actors as MARender Web Page', self)
    fExportActorsMAR.setStatusTip('Export actors as MARender web page')
    fExportActorsMAR.triggered.connect(self.setupExportActorsForMAR)
    self._export_mar.accepted.connect(self.exportActorsForMAR)
    fMenu.addAction(fExportActorsMAR)
    # 
    self._export_marv = ExportMARVDialog()
    fExportActorsMARV = QtWidgets.QAction(
                            'Export Actors as MARenderView config', self)
    fExportActorsMAR.setStatusTip( \
        'Export actors as MARenderView configuration file')
    fExportActorsMARV.triggered.connect(self.setupExportActorsForMARV)
    self._export_marv.accepted.connect(self.exportActorsForMARV)
    fMenu.addAction(fExportActorsMARV)
    #
    fLoadActors = QtWidgets.QAction(QtGui.QIcon('save.png'), \
                                'Load Actor Settings', self)
    fLoadActors.setStatusTip('Load actor settings')
    fLoadActors.triggered.connect(self.loadActors)
    fMenu.addAction(fLoadActors)
    #
    fImportITKSnap = QtWidgets.QAction(QtGui.QIcon('save.png'), \
                                'Import ITK-SnAP Label Surfaces', self)
    fImportITKSnap.setStatusTip('Import ITK-SnAP Label Surfaces')
    fImportITKSnap.triggered.connect(self.importITKSnap)
    fMenu.addAction(fImportITKSnap)
    #
    fExit  = QtWidgets.QAction(QtGui.QIcon('exit.png'), 'Exit', self)
    fExit.setShortcut('Ctrl+Q')
    fExit.setStatusTip('Exit Application')
    fExit.triggered.connect(self.quit)
    fMenu.addAction(fExit)
    ##
    eDebug = QtWidgets.QAction('Debugging', eMenu, checkable=True)
    eDebug.setShortcut('Ctrl+D')
    eDebug.setStatusTip('Enable/disable debug messages.')
    eDebug.triggered.connect(self.toggleDebug)
    eDebug.setChecked(_debug)
    eMenu.addAction(eDebug)
    ##
    self._movie = MovieCreationDialog()
    aMovie = QtWidgets.QAction('Create Movie', self)
    aMovie.setShortcut('Ctrl+M')
    aMovie.setStatusTip('Open movie creation dialog')
    aMovie.triggered.connect(self.createMovie)
    aMenu.addAction(aMovie)
    self._movie.getStartPB().clicked.connect(self.movieStart)
    self._movie.getStopPB().clicked.connect(self.movieStop)
    ##
    vSetBackground = QtWidgets.QAction('Set Background', self)
    vSetBackground.setShortcut('Ctrl+B')
    vSetBackground.setStatusTip('Set render window background colour')
    vSetBackground.triggered.connect(self.setBackground)
    vMenu.addAction(vSetBackground)
    #
    vShowTable = QtWidgets.QAction('Show Actor Table', self)
    vShowTable.setShortcut('Ctrl+T')
    vShowTable.setStatusTip('Show actor table')
    vShowTable.triggered.connect(self.showTable)
    vMenu.addAction(vShowTable)
    #
    vGoHome = QtWidgets.QAction('Go Home', self)
    vGoHome.setShortcut('Ctrl+H')
    vGoHome.setStatusTip('Go to home view')
    vGoHome.triggered.connect(self.goHome)
    vMenu.addAction(vGoHome)
    #
    vSetHome = QtWidgets.QAction('Set Home', self)
    vSetHome.setShortcut('Ctrl+H')
    vSetHome.setStatusTip('Set home view')
    vSetHome.triggered.connect(self.setHome)
    vMenu.addAction(vSetHome)
    #
    vViewAll = QtWidgets.QAction('View All', self)
    vViewAll.setShortcut('Ctrl+R')
    vViewAll.setStatusTip('View all actors')
    vViewAll.triggered.connect(self.resetView)
    vMenu.addAction(vViewAll)
    ##
    self.controls = ControlsDialog()
    hControls = QtWidgets.QAction(QtGui.QIcon('help.png'), 'Controls', self)
    hControls.setStatusTip('Interactive controls')
    hControls.triggered.connect(self.showControls)
    hMenu.addAction(hControls)
    #
    self.about = AboutDialog(self._version)
    hAbout = QtWidgets.QAction(QtGui.QIcon('help.png'), 'About', self)
    hAbout.setStatusTip('About MAVTKSurfViewer')
    hAbout.triggered.connect(self.showAbout)
    hMenu.addAction(hAbout)
    #
    self.statusBar()
    self.setGeometry(256, 256, 768, 768)
    self.setWindowTitle('MAVTKSurfViewer')
    #
    self._actors.visableChangeSignal.connect(self.setActorVisible)
    self._actors.colorChangeSignal.connect(self.setActorColor)
    self._actors.opacityChangeSignal.connect(self.setActorOpacity)
    #
    self.ren = MAVTKRenderer()
    self.setCentralWidget(self.ren.getFrame())
    self.show()
    self.ren.init()
    # Read files given on command line
    r = 4203829009 # seed for an OK sequence of colors
    for f in files: #{
      self.addSurf(True, os.path.basename(f), iCol, self._def_opacity, f)
      r = self._getRandomColor(r, iCol)
    #}
    # Add pick observer
    self.ren.getPicker().AddObserver("EndPickEvent", self.cellPicked)
    # Reset the camera to view all and make it the initial home view
    self.ren.getRen().ResetCamera()
    self.setHome()
  #}

  ###
  # \function  _getRandomColor
  # \brief     Gets a random colour as a VTK tripple float colour array.
  #            The previous value is used to ensure a repeatable random
  #            sequence. The values selected use a basic Lehmer random number
  #            generator but the values are constrained a little to avoid
  #            almost black or almost white colours.
  # \return    Value used to ensure repeatable sequence.
  # \param r                   Previous value returned.
  # \param cols                Array of three floats for VTK colours, set
  #                            on return.
  ###
  def _getRandomColor(self, r, cols): #{
    d = 0.0
    e = 0.0
    while (d < 1.0) and ((e < 1.0) or (e > 2.0)): #{
      d = 0.0
      e = 0.0
      for i in range(0,3): #{
        if r == 0: #{
          r = 255
        else: #}{
          r = (r * 279470273) % 4294967291
        #}
        c = float(r & 255) / 255.0
        d = d + math.fabs(c - cols[i])
        e = e + c
        cols[i] = c
      #}
    #}
    return r
  #}

  ###
  # \function quit
  # \brief    Slot to quit the application.
  ###
  def quit(self): #{
    sys.exit(0)
  #}


  ###
  # \function   showAbout
  # \brief      Slot to show the application about dialog.
  ###
  def showAbout(self): #{
    self.about.show()
  #}

  ###
  # \function   showControls
  # \brief      Slot to show the controls help dialog.
  ###
  def showControls(self): #{
    self.controls.show()
  #}

  ###
  # \function   cellPicked
  # \brief      Handles VTK actor being picked.
  ###
  def cellPicked(self, object, event): #{
    picker = self.ren.getPicker()
    pt = picker.GetPointId()
    cell = picker.GetCellId()
    pos = picker.GetPickPosition()
    print(pt)
    print(cell)
    print(pos)
    self.statusBar().showMessage('Pick: point = ' + str(pt) + \
                                 ', cell = ' + str(cell) + \
                                 ', pos = ' + str(pos))
    if picker.GetCellId() >= 0: #{
      pActor = picker.GetActor();
      actorArray = self._actors._actors
      for idx in range(0, len(actorArray)): #{
        if actorArray[idx] == pActor: #{
          self._actors.selectActor(idx)
        #}
      #}
    #}
  #}

  ###
  # \function  addSurf
  # \brief     Adds a surface to the viewer.
  # \param visible             Actor visibility (boolean).
  # \param name                Actor name.
  # \param v_col               Actor colour as a VTK triple float array.
  # \param opacity             Actor opacity as a float with range [0.0-1.0].
  # \param path                Actor file path.
  ### 
  def addSurf(self, visible, name, v_col, opacity, path): #{
    reader = None
    file_type = path.split(".")[-1]
    if file_type in self._file_formats: #{
      if file_type == 'obj': #{
        reader = vtk.vtkOBJReader()
      elif file_type == 'stl': #}{
        reader = vtk.vtkSTLReader()
      elif file_type == 'vtk': #}{
        reader = vtk.vtkPolyDataReader()
    #}
    reader.SetFileName(path)
    mapper = vtk.vtkPolyDataMapper()
    mapper.SetInputConnection(reader.GetOutputPort())
    actor = vtk.vtkActor()
    actor.SetMapper(mapper)
    actor.GetProperty().SetOpacity(opacity)
    actor.GetProperty().SetDiffuseColor(v_col)
    actor.GetProperty().SetAmbient(0.2);
    actor.GetProperty().SetDiffuse(0.6);
    actor.GetProperty().SetSpecular(0.2);
    actor.GetProperty().SetSpecularPower(3.0);
    actor.SetVisibility(int(visible))
    self.ren.getRen().AddActor(actor)
    self.ren.Render()
    q_col = QtGui.QColor(255 * v_col[0], 255 * v_col[1], 255 * v_col[2])
    self._actors.addActor(actor, visible, name, q_col, opacity, path)
  #}

  ###
  # \function  openFile
  # \brief     Opens a file, reads a surface and adds an actor for it.
  ###
  def openFile(self): #{
    c = ''
    s = 'Surface files ('
    for f in self._file_formats:
      s = s + c + '*.' + f
      c = ' '
    s = s + ');; All files (*)'
    path = QtWidgets.QFileDialog.getOpenFileName(self, 'Open surface file',
               self._current_path, s)
    if(path): #{
      p = str(path[0])
      self.addSurf(True, os.path.basename(p), self._def_color, 
                   self._def_opacity, p)
    #}
  #}

  ###
  # \function  saveImage
  # \brief     Prompts for file path using a QFileDialog and then saves
  #            the current rendered image to the file.
  ###
  def saveImage(self): #{
    path = QtWidgets.QFileDialog.getSaveFileName(self, 'Write rendered image',
               self._current_path,
               'Image files (*.bmp *.png *.pnm *.tif *.tiff);;' +
               'All files (*)')
    if(path): #{
      self.ren.Render()
      p = path[0]
      if self.ren.writeFrameToFile(p):
        QtWidgets.QMessageBox.critical(self,
                   'Error',
                   'Failed to write image to file ' + p + '.',
                   QtWidgets.QMessageBox.Close)
    #}
  #}

  ###
  # \function  saveActors
  # \brief     Prompts for a file path and then saves the current actor
  #            settings to the file. The settings are saved using a json
  #            dump.
  ###
  def saveActors(self): #{
    path = QtWidgets.QFileDialog.getSaveFileName(self, 'Write actor settings',
               self._current_path,
               'Actor settings files (*.jsn *.json);;All files (*)')
    if(path): #{
      path = path[0]
      n_act = self._actors.getNumActors()
      act_ary = []
      for idx in range(0, n_act): #{
        col = self._actors.getActorColor(idx)
        act_ary.append( \
          { \
            'visible' : self._actors.getActorVisability(idx), \
            'name': self._actors.getActorName(idx), \
            'color': [col.red(), col.blue(), col.green()], \
            'opacity': self._actors.getActorOpacity(idx), \
            'path': self._actors.getActorPath(idx) \
          })
      #}
      data = { \
        'ident': self._actor_file_ident, \
        'version': self._version, \
        'num_actors': n_act, \
        'actors': act_ary
        }
      if(path): #{
        try: #{
          f = io.open(str(path), 'w', encoding='utf-8')
          f.write(json.dumps(data))
          f.close()
        except: #}{
          QtWidgets.QMessageBox.critical(self,
              'Error',
              'Failed to write actor setting to file ' + path + '.',
              QtWidgets.QMessageBox.Close)
        #}
      #}
    #}
  #}

  ###
  # \function setupExportActorsForMAR
  # \brief    Sets parameters required to export the current actor
  #           settings to a web page which uses MARender and three.js
  ###
  def setupExportActorsForMARV(self): #{
    self._export_marv.show()
  #}

  ###
  # \function setupExportActorsForMAR
  # \brief    Sets parameters required to export the current actor
  #           settings to a web page which uses MARender and three.js
  ###
  def setupExportActorsForMAR(self): #{
    self._export_mar.show()
  #}

  ###
  # \function exportActorsForMAR
  # \brief    Prompts for a file path and then exports the current actor
  #           settings to a web page which uses MARender and three.js
  ###
  def exportActorsForMAR(self): #{
    ttl = self._export_mar.getPageTitle()
    inf = self._export_mar.getPageInfo()
    path = QtWidgets.QFileDialog.getSaveFileName(self,
               'Export actors for web page',
               self._current_path,
               'HTML files (*.html);;All files (*)')
    page_text = html_page[0] + \
                '\n<title>' + ttl + '</title>\n' + \
                html_page[1] + \
                '\n<div id="info">\n' + inf + '\n</div>\n' + \
                html_page[2];
    pos = self._home.position
    cen = self._home.focalPoint
    rng = self._home.clippingRange
    up = self._home.viewUp
    page_text = page_text + \
                '\n' + \
                'ren.setCamera(' + \
                  'new THREE.Vector3(' + \
                    str(cen[0]) + ', ' + \
                    str(cen[1]) + ', ' + \
                    str(cen[2]) + '), ' + \
                  str(rng[0]) + ', ' + str(rng[1]) + ', ' + \
                  'new THREE.Vector3(' + \
                    str(pos[0]) + ', ' + \
                    str(pos[1]) + ', ' + \
                    str(pos[2]) + '));\n' + \
                'ren.setHome(' + \
                  'new THREE.Vector3(' + \
                    str(pos[0]) + ', ' + \
                    str(pos[1]) + ', ' + \
                    str(pos[2]) + '),' + \
                  'new THREE.Vector3(' + \
                    str(up[0]) + ', ' + \
                    str(up[1]) + ', ' + \
                    str(up[2]) + '));\n'
    n_act = self._actors.getNumActors()
    for idx in range(0, n_act): #{
      if self._actors.getActorVisability(idx): #{
        col = self._actors.getActorColor(idx)
        page_text = page_text + \
                    'ren.addModel({name:        \'' + \
                    self._actors.getActorName(idx) + '\',\n' + \
                    '              path:        \'' + \
                    self._actors.getActorPath(idx) + '\',\n' + \
                    '              transparent: true,\n' + \
                    '              opacity:     ' + \
                    str(self._actors.getActorOpacity(idx)) + ',\n' + \
                    '              color:       0x' + \
                    col.name()[1:] + ',\n' + \
                    '              mode:        MARenderMode.PHONG});\n'
      #}
    #}
    page_text = page_text + html_page[3]
    p = path[0]
    try: #{
      f = open(p, 'w')
      f.write(page_text)
      f.close()
    except: #}{
        QtWidgets.QMessageBox.critical(self,
            'Error',
            'Failed to export actors as web page file ' + p + '.',
            QtWidgets.QMessageBox.Close)
      #}
  #}

  ###
  # \function exportActorsForMARV
  # \brief    Prompts for a file path and then exports the current actor
  #           settings to a json MARenderView configuration file.
  ###
  def exportActorsForMARV(self): #{
    path = QtWidgets.QFileDialog.getSaveFileName(self,
               'Export actors for MARenderView',
               self._current_path,
               'Json files (*.jsn *.json);;All files (*)')
    ttl = self._export_marv.getPageTitle()
    inf = self._export_marv.getPageInfo()
    iip_srv = self._export_marv.getIIPSrv()
    ref_idx = self._export_marv.getRefIdx()
    n_act = self._actors.getNumActors()
    pos = self._home.position
    cen = self._home.focalPoint
    rng = self._home.clippingRange
    up = self._home.viewUp
    three_view = { \
                   'cen':  {'x': cen[0], 'y': cen[1], 'z': cen[2]}, \
                   'near': rng[0], \
                   'far':  rng[1],
                   'pos':  {'x': pos[0], 'y': pos[1], 'z': pos[2]},
                   'up':   {'x': up[0], 'y': up[1], 'z': up[2]}
                 }
    section_view = { \
                     'dst': 0, \
                     'pit': 0, \
                     'yaw': 0, \
                     'fxp': {'x' : 0, 'y': 0, 'z': 0}
                   }
    section = { \
                'idx': 0, \
                'name': 'section', \
                'transparent': True, \
                'color': '0xffffff', \
                'opacity': 1.0, \
                'wlz': 'null'
              }
    domains = []
    for idx in range(0, n_act): #{
      if self._actors.getActorVisability(idx): #{
        col = self._actors.getActorColor(idx)
        trans = ((self._actors.getActorOpacity(idx) + 0.0001) < 1.0);
        hexcol = '0x' + str(col.name()[1:])
        domains.append( \
          { \
            'idx' : idx, \
            'name': self._actors.getActorName(idx), \
            'path': self._actors.getActorPath(idx), \
            'transparent': trans, \
            'color': hexcol, \
            'opacity': self._actors.getActorOpacity(idx)
          })
      #}
    #}
    config = { \
      'title': ttl,
      'info': inf,
      'three_view': three_view,
      'iip3dsrv': iip_srv, 
      'show_gui': False,
      'outer_idx': ref_idx,
      'section_view': section_view,
      'section': section, 
      'domains': domains
      }
    if(path): #{
      p = path[0]
      try: #{
        f = open(p, 'w', encoding='utf-8')
        f.write(json.dumps(config))
        f.close()
      except: #}{
        QtWidgets.QMessageBox.critical(self,
            'Error',
            'Failed to write MARenderView config to file ' + \
            p + '.',
            QtWidgets.QMessageBox.Close)
      #}
    #}
  #}

  ###
  # \function  loadActors
  # \brief     Prompts for a file path and then reads actor settings from the
  #            file, where these have been saved using the json format of
  #            saveActors(). The actors are added and do not replace existing
  #            actors.
  ###
  def loadActors(self): #{
    path = QtWidgets.QFileDialog.getOpenFileName(self, 'Load actor settings',
               self._current_path,
               'Json files (*.jsn *.json);;All files (*)')
    if(path): #{
      path = path[0]
      n_act = 0
      data = None
      try: #{
        f = io.open(str(path), 'r')
        data = json.load(f)
        f.close()
        if bool(data): #{
          n_act = int(data['num_actors'])
          if (not str(data['ident']) == self._actor_file_ident) or \
             (n_act < 0): #{
            data = None
          #}
        #}
      except: #}{
        data = None
      #}
      if bool(data): #{
        act_ary = data['actors']
        for idx in range(0, n_act): #{
          act = act_ary[idx]
          try: #{
            name = str(act['name'])
          except: #}{
            name = str(idx)
          #}
          try: #{
            col = act['color']
            v_col = [float(col[0]) / 255.0, \
                     float(col[1]) / 255.0, \
                     float(col[2]) / 255.0]
          except: #}{
            v_col = [1.0, 1.0, 1.0]
          #}
          try: #{
            visible = bool(act['visible'])
          except: #}{
            visible = True
          #}
          try: #{
            opacity = float(act['opacity'])
          except: #}{
            opacity = 1.0
          #}
          path = str(act['path'])
          self.addSurf(visible, name, v_col, opacity, path)
        #}
      #}
      if bool(data): #{
        self.resetView()
      else: # }{
        QtWidgets.QMessageBox.critical(self,
            'Error',
            'Failed to write actor setting to file ' + path + '.',
            QtWidgets.QMessageBox.Close)
               
      #}
    #}
  #}

  ###
  # \function  importITKSnap
  # \brief     Prompts for a file path and then reads actor settings from the
  #            file, where these have been saved using the ITK-SnAP label
  #            deescription file format. The actors are added and do not
  #            replace existing actors.
  ###
  def importITKSnap(self): #{
    path = QtWidgets.QFileDialog.getOpenFileName(self, 'Import ITK-SnAP Surfaces',
               self._current_path,
               'Text files (*.txt);;All files (*)')
    if bool(path): #{
      path = path[0]
      n_act = 0
      ln_num = 1
      data = None
      valid = False;
      try: #{
        f = io.open(str(path), 'r')
        for ln in f: #{
          rec = str(ln)
          ln_num = ln_num + 1
          if not valid: #{
            valid = bool(re.match('^#.*ITK.SnAP Label Description File', rec))
          else: #}{
            if not re.match('^#', rec): #{
              fld = rec.split()
              if len(fld) < 8: #{
                raise
              #}
              idx = int(fld[0])
              col = [float(fld[1]) / 255.0, \
                     float(fld[2]) / 255.0, \
                     float(fld[3]) / 255.0]
              opy = float(fld[4])
              isvis = int(fld[5]) > 0
              ismesh = int(fld[6]) > 0
              if ismesh: #{
                name = re.sub('"', '', ' '.join(fld[7:]))
                mesh_path = re.sub('\.txt$', '{:05d}'.format(idx) + '.vtk', \
                                   str(path))
                self.addSurf(isvis, name, col, opy, mesh_path)
              #}
            #}
          #}
        #}
      except Exception as e: #}{
        print(str(e))
        valid = False;
      #}
      if valid: #{
        self.resetView()
      else: # }{
        QtWidgets.QMessageBox.critical(self,
            'Error',
            'Failed to import actors from ITK SnAP file ' + path + \
                ' (line ' + str(ln_num) + ')',
            QtWidgets.QMessageBox.Close)
               
      #}
    #}
  #}

  ###
  # \function   getNumActors
  # \brief      Access method to get the number of actors.
  # \return     Number of actors.
  ###
  def getNumActors(self): #{
    return self._table.rowCount()
  #}

  ###
  # \function   getActor
  # \brief      Access the actor corresponding to the given index.
  # \return     Actor.
  ###
  def getActor(self, idx): #{
    actor = self._actors[idx]
    return actor
  #}

  ###
  # \function   getActorName
  # \brief      Access the name of the actor with the given index.
  # \return     Actor name string.
  ###
  def getActorName(self, idx): #{
    name = str(self._table.item(idx, self.tableDict['Name']).text())
    return name
  #}

  ###
  # \function   getActorColor
  # \brief      Access the actor colour for the actor with the given index.
  # \return     Actor colour (QColor).
  ###
  def getActorColor(self, idx): #{
    q_col = self._table.item(idx, self.tableDict['Color']).getColor()
    return q_col
  #}

  ###
  # \function   getActorOpacity
  # \brief      Access the opacity of the actor with the given index.
  # \return     Actor opacity.
  ###
  def getActorOpacity(self, idx): #{
    opacity = float(self._table.item(idx, self.tableDict['Opacity']).text())
    return opacity
  #}

  ###
  # \function   getActorPath
  # \brief      Access the file path of the actor with the given index.
  # \return     Actor file path string.
  ###
  def getActorPath(self, idx): #{
    path = str(self._table.item(idx, self.tableDict['Path']).text())

  def createMovie(self): #{
    self._movie.show()
  #}

  ###
  # \function  movieStop
  # \brief     Stop any movie creation by setting a flag.
  ###
  def movieStop(self): #{
    self._movie.setStateStop()
  #}

  ###
  # \function  animationLoop
  # \brief     Renders a single frame of a movie, saves it to a file and
  #            then checks for a flag set to destroy the timer which
  #            might call this function.
  ###
  def animationLoop(self, object, event): #{
    self.ren.Render()
    self.saveMovieFrame()
    if self._movie.stateIsStop(): #{
      self.ren.getIRen().DestroyTimer(self._animation)
    #}
  #}

  ###
  # \function  movieStart
  # \brief     Starts creating movie images.
  #            If the number of steps is greater than zero then the
  #            fixed animation is run, otherwise frames are stored as
  #            rendered until the movie creation process is stopped.
  ###
  def movieStart(self): #{
    img = vtk.vtkWindowToImageFilter()
    if self._movie.stateIsStop(): #{
      self._movie.setStateRun()
      cam = self.ren.getRen().GetActiveCamera()
      rot = self._movie.getDegPerStep()
      axis = self._movie.getAxis()
      nSteps = self._movie.getNumStep()
      if nSteps > 0: #{
        for step in range(0, nSteps): #{
          if axis == 'X': #{
            cam.Elevation(rot)
          elif axis == 'Y': #}{
            cam.Azimuth(rot)
          else: # axis == 'Z' #}{
            cam.Roll(rot)
          #}
          cam.OrthogonalizeViewUp()
          self.ren.Render()
          self.saveMovieFrame()
          if self._movie.stateIsStop(): #{
            break
          #}
        #}
        if not self._movie.stateIsStop(): #{
          self._movie.setStateStop()
        #}
      #}
      else: #{
        iren = self.ren.getIRen()
        self._animation = iren.CreateRepeatingTimer(100)
        iren.AddObserver('TimerEvent', self.animationLoop, 0.0)
        self._movie.setStateRun()
    else: #}{
      QtWidgets.QMessageBox.critical(self,
                   'Warning',
                   'Movie creation already active.',
                   QtWidgets.QMessageBox.Close)
      #}
    #}
      
  ###
  # \function  saveMovieFrame
  # \brief     Save a rendered image to a file with a path formed by the
  #            base path and an appended index counter.
  ###
  def saveMovieFrame(self): #{
    idx = self._movie.getFileIndex()
    base_path = self._movie.getFilename()
    if bool(base_path): #{
      base_dir = os.path.dirname(base_path)
      split_base_file = os.path.splitext(os.path.basename(base_path))
      path = base_dir + '/' + split_base_file[0] + \
             '_' + '{:08}'.format(idx) + split_base_file[1]
      self.ren.writeFrameToFile(path)
      self._movie.incFileIndex()
    #}
  #}

  ###
  # \function setBackground
  # \brief    Prompts the user for a color and then uses it to set the
  #           background colour of the render window.
  ###
  def setBackground(self): #{
    q_col = QtWidgets.QColorDialog.getColor()
    if q_col.isValid(): #{
      v_col = [q_col.red() / 255.0, q_col.green() / 255.0, q_col.blue() / 255.0]
      self.ren.getRen().SetBackground(v_col)
    #}
  #}

  ###
  # \function showTable
  # \brief    Slot to show the actor table.
  ###
  def showTable(self): #{
    if self._actors.isVisible(): #{
      self._actors.hide()
    else: #}{
      self._actors.show()
    #}
  #}

  ###
  # \function goHome
  # \brief    Slot which presents the scene home view.
  ###
  def goHome(self): #{
    if bool(self._home): #{
      self.ren.setView(self._home)
    #}
  #}

  ###
  # \function setHome
  # \brief    Slot which sets the scene home view to the current view.
  ###
  def setHome(self): #{
    self._home = self.ren.getView()
    debugMsg('Setting home:\n' + \
      'position = ' + str(self._home.position) + '\n' + \
      'focalPoint = ' + str(self._home.focalPoint) + '\n' + \
      'viewUp = ' + str(self._home.viewUp) + '\n' + \
      'viewAngle = ' + str(self._home.viewAngle) + '\n' + \
      'parallelScale = ' + str(self._home.parallelScale) + '\n' + \
      'clippingRange = ' + str(self._home.clippingRange) + '\n')
  #}

  ###
  # \function  resetView
  # \brief     Resets the camera to make sure that all actors ar visible.
  ###
  def resetView(self): #{
    self.ren.getRen().ResetCamera()
    self.ren.Render()
  #}

  ###
  # \function  setActorVisible
  # \brief     Sets the actor visibility to the given state in both the actor
  #            table and the VTK render window.
  # \param idx                 Index of the actor in the actor table.
  # \param state               required visibility (boolean).
  ###
  def setActorVisible(self, idx, state): #{
    actor = self._actors.getActor(idx)
    actor.SetVisibility(state)
    self._actors.setActorVisible(idx, state)
    self.ren.Render()
  #}

  ###
  # \function  setActorColor
  # \brief     Sets the actor colour in both the actor table and the VTK
  #            render window.
  # \param idx                 Index of the actor in the actor table.
  # \param q_col               Colour in QColor form.
  ###
  def setActorColor(self, idx, q_col): #{
    actor = self._actors.getActor(idx)
    v_col = [q_col.red() / 255.0, q_col.green() / 255.0, q_col.blue() / 255.0]
    actor.GetProperty().SetDiffuseColor(v_col)
    self._actors.setActorColor(idx, q_col)
    self.ren.Render()
  #}

  ###
  # \function  setActorOpacity
  # \brief     Sets the actor opacity in both the actor table and the VTK
  #            render window.
  # \param idx                 Index of the actor in the actor table.
  # \param q_col               Opacity as a flaot, range [0.0-1.0].
  ###
  def setActorOpacity(self, idx, op): #{
    actor = self._actors.getActor(idx)
    actor.GetProperty().SetOpacity(op)
    self._actors.setActorOpacity(idx, op)
    self.ren.Render()
  #}

###
# \function  main
# \brief     Main function for the application which parses any command line
#            options then passes any files given on the command line to the
#            main application constructor.
###
def main(): #{
  global _debug
  app = QtWidgets.QApplication(sys.argv)
  parser = argparse.ArgumentParser(
      description='Interactive display of surfaces.',
      epilog='Supported surface formats are: ' +
             str(MAVTKSurfViewer._file_formats) + '.\n')
  parser.add_argument('-d', '--debug',
      action='store_true', default=False, \
      help='Set debugging to stderr on.')
  parser.add_argument('-v', '--version',
      action='store_true', default=False, \
      help='Show version and exit.')
  parser.add_argument('file', nargs='*')
  args = parser.parse_args()
  if(args.version): #{
    print('MAVTKSurfViewer=' + MAVTKSurfViewer._version)
    print('python=' + sys.version)
    print('qt=' + QT_VERSION_STR + ', pyqt=' + PYQT_VERSION_STR)
    print('vtk=' + vtk.vtkVersion().GetVTKVersion())
    sys.exit(0)
  #}
  if(args.debug): #{
    _debug = True
  #}
  sv = MAVTKSurfViewer(args.file)
  sys.exit(app.exec_())
#}


if __name__ == '__main__': #{
  main()
#}

